// Copyright 2024 Nokia
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.6
// 	protoc        v5.29.3
// source: schema.proto

package schema_server

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type SchemaStatus int32

const (
	SchemaStatus_OK           SchemaStatus = 0 // all good
	SchemaStatus_RELOADING    SchemaStatus = 1 // reloading YANG, should be locked
	SchemaStatus_INITIALIZING SchemaStatus = 2 // initial state after creation
	SchemaStatus_FAILED       SchemaStatus = 3 // chema files parsing failed, yang load failed
)

// Enum value maps for SchemaStatus.
var (
	SchemaStatus_name = map[int32]string{
		0: "OK",
		1: "RELOADING",
		2: "INITIALIZING",
		3: "FAILED",
	}
	SchemaStatus_value = map[string]int32{
		"OK":           0,
		"RELOADING":    1,
		"INITIALIZING": 2,
		"FAILED":       3,
	}
)

func (x SchemaStatus) Enum() *SchemaStatus {
	p := new(SchemaStatus)
	*p = x
	return p
}

func (x SchemaStatus) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (SchemaStatus) Descriptor() protoreflect.EnumDescriptor {
	return file_schema_proto_enumTypes[0].Descriptor()
}

func (SchemaStatus) Type() protoreflect.EnumType {
	return &file_schema_proto_enumTypes[0]
}

func (x SchemaStatus) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use SchemaStatus.Descriptor instead.
func (SchemaStatus) EnumDescriptor() ([]byte, []int) {
	return file_schema_proto_rawDescGZIP(), []int{0}
}

type DataType int32

const (
	DataType_ALL    DataType = 0
	DataType_CONFIG DataType = 1
	DataType_STATE  DataType = 2
)

// Enum value maps for DataType.
var (
	DataType_name = map[int32]string{
		0: "ALL",
		1: "CONFIG",
		2: "STATE",
	}
	DataType_value = map[string]int32{
		"ALL":    0,
		"CONFIG": 1,
		"STATE":  2,
	}
)

func (x DataType) Enum() *DataType {
	p := new(DataType)
	*p = x
	return p
}

func (x DataType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (DataType) Descriptor() protoreflect.EnumDescriptor {
	return file_schema_proto_enumTypes[1].Descriptor()
}

func (DataType) Type() protoreflect.EnumType {
	return &file_schema_proto_enumTypes[1]
}

func (x DataType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use DataType.Descriptor instead.
func (DataType) EnumDescriptor() ([]byte, []int) {
	return file_schema_proto_rawDescGZIP(), []int{1}
}

type UploadSchemaFile_FileType int32

const (
	UploadSchemaFile_MODULE     UploadSchemaFile_FileType = 0
	UploadSchemaFile_DEPENDENCY UploadSchemaFile_FileType = 1
)

// Enum value maps for UploadSchemaFile_FileType.
var (
	UploadSchemaFile_FileType_name = map[int32]string{
		0: "MODULE",
		1: "DEPENDENCY",
	}
	UploadSchemaFile_FileType_value = map[string]int32{
		"MODULE":     0,
		"DEPENDENCY": 1,
	}
)

func (x UploadSchemaFile_FileType) Enum() *UploadSchemaFile_FileType {
	p := new(UploadSchemaFile_FileType)
	*p = x
	return p
}

func (x UploadSchemaFile_FileType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (UploadSchemaFile_FileType) Descriptor() protoreflect.EnumDescriptor {
	return file_schema_proto_enumTypes[2].Descriptor()
}

func (UploadSchemaFile_FileType) Type() protoreflect.EnumType {
	return &file_schema_proto_enumTypes[2]
}

func (x UploadSchemaFile_FileType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use UploadSchemaFile_FileType.Descriptor instead.
func (UploadSchemaFile_FileType) EnumDescriptor() ([]byte, []int) {
	return file_schema_proto_rawDescGZIP(), []int{15, 0}
}

type Hash_HashMethod int32

const (
	Hash_UNSPECIFIED Hash_HashMethod = 0 // Error
	Hash_MD5         Hash_HashMethod = 1
	Hash_SHA256      Hash_HashMethod = 2
	Hash_SHA512      Hash_HashMethod = 3
)

// Enum value maps for Hash_HashMethod.
var (
	Hash_HashMethod_name = map[int32]string{
		0: "UNSPECIFIED",
		1: "MD5",
		2: "SHA256",
		3: "SHA512",
	}
	Hash_HashMethod_value = map[string]int32{
		"UNSPECIFIED": 0,
		"MD5":         1,
		"SHA256":      2,
		"SHA512":      3,
	}
)

func (x Hash_HashMethod) Enum() *Hash_HashMethod {
	p := new(Hash_HashMethod)
	*p = x
	return p
}

func (x Hash_HashMethod) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (Hash_HashMethod) Descriptor() protoreflect.EnumDescriptor {
	return file_schema_proto_enumTypes[3].Descriptor()
}

func (Hash_HashMethod) Type() protoreflect.EnumType {
	return &file_schema_proto_enumTypes[3]
}

func (x Hash_HashMethod) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use Hash_HashMethod.Descriptor instead.
func (Hash_HashMethod) EnumDescriptor() ([]byte, []int) {
	return file_schema_proto_rawDescGZIP(), []int{20, 0}
}

type Schema struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// string type = 1;
	Name          string       `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Vendor        string       `protobuf:"bytes,3,opt,name=vendor,proto3" json:"vendor,omitempty"`
	Version       string       `protobuf:"bytes,4,opt,name=version,proto3" json:"version,omitempty"`
	Status        SchemaStatus `protobuf:"varint,5,opt,name=status,proto3,enum=schema.SchemaStatus" json:"status,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Schema) Reset() {
	*x = Schema{}
	mi := &file_schema_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Schema) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Schema) ProtoMessage() {}

func (x *Schema) ProtoReflect() protoreflect.Message {
	mi := &file_schema_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Schema.ProtoReflect.Descriptor instead.
func (*Schema) Descriptor() ([]byte, []int) {
	return file_schema_proto_rawDescGZIP(), []int{0}
}

func (x *Schema) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *Schema) GetVendor() string {
	if x != nil {
		return x.Vendor
	}
	return ""
}

func (x *Schema) GetVersion() string {
	if x != nil {
		return x.Version
	}
	return ""
}

func (x *Schema) GetStatus() SchemaStatus {
	if x != nil {
		return x.Status
	}
	return SchemaStatus_OK
}

// RPC messages
type GetSchemaDetailsRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Schema        *Schema                `protobuf:"bytes,1,opt,name=schema,proto3" json:"schema,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetSchemaDetailsRequest) Reset() {
	*x = GetSchemaDetailsRequest{}
	mi := &file_schema_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetSchemaDetailsRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetSchemaDetailsRequest) ProtoMessage() {}

func (x *GetSchemaDetailsRequest) ProtoReflect() protoreflect.Message {
	mi := &file_schema_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetSchemaDetailsRequest.ProtoReflect.Descriptor instead.
func (*GetSchemaDetailsRequest) Descriptor() ([]byte, []int) {
	return file_schema_proto_rawDescGZIP(), []int{1}
}

func (x *GetSchemaDetailsRequest) GetSchema() *Schema {
	if x != nil {
		return x.Schema
	}
	return nil
}

type GetSchemaDetailsResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Schema        *Schema                `protobuf:"bytes,1,opt,name=schema,proto3" json:"schema,omitempty"` // with status
	File          []string               `protobuf:"bytes,2,rep,name=file,proto3" json:"file,omitempty"`
	Directory     []string               `protobuf:"bytes,3,rep,name=directory,proto3" json:"directory,omitempty"`
	Exclude       []string               `protobuf:"bytes,4,rep,name=exclude,proto3" json:"exclude,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetSchemaDetailsResponse) Reset() {
	*x = GetSchemaDetailsResponse{}
	mi := &file_schema_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetSchemaDetailsResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetSchemaDetailsResponse) ProtoMessage() {}

func (x *GetSchemaDetailsResponse) ProtoReflect() protoreflect.Message {
	mi := &file_schema_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetSchemaDetailsResponse.ProtoReflect.Descriptor instead.
func (*GetSchemaDetailsResponse) Descriptor() ([]byte, []int) {
	return file_schema_proto_rawDescGZIP(), []int{2}
}

func (x *GetSchemaDetailsResponse) GetSchema() *Schema {
	if x != nil {
		return x.Schema
	}
	return nil
}

func (x *GetSchemaDetailsResponse) GetFile() []string {
	if x != nil {
		return x.File
	}
	return nil
}

func (x *GetSchemaDetailsResponse) GetDirectory() []string {
	if x != nil {
		return x.Directory
	}
	return nil
}

func (x *GetSchemaDetailsResponse) GetExclude() []string {
	if x != nil {
		return x.Exclude
	}
	return nil
}

type ListSchemaRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ListSchemaRequest) Reset() {
	*x = ListSchemaRequest{}
	mi := &file_schema_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ListSchemaRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListSchemaRequest) ProtoMessage() {}

func (x *ListSchemaRequest) ProtoReflect() protoreflect.Message {
	mi := &file_schema_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListSchemaRequest.ProtoReflect.Descriptor instead.
func (*ListSchemaRequest) Descriptor() ([]byte, []int) {
	return file_schema_proto_rawDescGZIP(), []int{3}
}

type ListSchemaResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Schema        []*Schema              `protobuf:"bytes,1,rep,name=schema,proto3" json:"schema,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ListSchemaResponse) Reset() {
	*x = ListSchemaResponse{}
	mi := &file_schema_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ListSchemaResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListSchemaResponse) ProtoMessage() {}

func (x *ListSchemaResponse) ProtoReflect() protoreflect.Message {
	mi := &file_schema_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListSchemaResponse.ProtoReflect.Descriptor instead.
func (*ListSchemaResponse) Descriptor() ([]byte, []int) {
	return file_schema_proto_rawDescGZIP(), []int{4}
}

func (x *ListSchemaResponse) GetSchema() []*Schema {
	if x != nil {
		return x.Schema
	}
	return nil
}

type GetSchemaRequest struct {
	state           protoimpl.MessageState `protogen:"open.v1"`
	Path            *Path                  `protobuf:"bytes,1,opt,name=path,proto3" json:"path,omitempty"`
	Schema          *Schema                `protobuf:"bytes,2,opt,name=schema,proto3" json:"schema,omitempty"`
	ValidateKeys    bool                   `protobuf:"varint,3,opt,name=validate_keys,json=validateKeys,proto3" json:"validate_keys,omitempty"`          // TODO
	WithDescription bool                   `protobuf:"varint,4,opt,name=with_description,json=withDescription,proto3" json:"with_description,omitempty"` // TODO
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *GetSchemaRequest) Reset() {
	*x = GetSchemaRequest{}
	mi := &file_schema_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetSchemaRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetSchemaRequest) ProtoMessage() {}

func (x *GetSchemaRequest) ProtoReflect() protoreflect.Message {
	mi := &file_schema_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetSchemaRequest.ProtoReflect.Descriptor instead.
func (*GetSchemaRequest) Descriptor() ([]byte, []int) {
	return file_schema_proto_rawDescGZIP(), []int{5}
}

func (x *GetSchemaRequest) GetPath() *Path {
	if x != nil {
		return x.Path
	}
	return nil
}

func (x *GetSchemaRequest) GetSchema() *Schema {
	if x != nil {
		return x.Schema
	}
	return nil
}

func (x *GetSchemaRequest) GetValidateKeys() bool {
	if x != nil {
		return x.ValidateKeys
	}
	return false
}

func (x *GetSchemaRequest) GetWithDescription() bool {
	if x != nil {
		return x.WithDescription
	}
	return false
}

type GetSchemaResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Schema        *SchemaElem            `protobuf:"bytes,1,opt,name=schema,proto3" json:"schema,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetSchemaResponse) Reset() {
	*x = GetSchemaResponse{}
	mi := &file_schema_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetSchemaResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetSchemaResponse) ProtoMessage() {}

func (x *GetSchemaResponse) ProtoReflect() protoreflect.Message {
	mi := &file_schema_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetSchemaResponse.ProtoReflect.Descriptor instead.
func (*GetSchemaResponse) Descriptor() ([]byte, []int) {
	return file_schema_proto_rawDescGZIP(), []int{6}
}

func (x *GetSchemaResponse) GetSchema() *SchemaElem {
	if x != nil {
		return x.Schema
	}
	return nil
}

type SchemaElem struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to Schema:
	//
	//	*SchemaElem_Container
	//	*SchemaElem_Field
	//	*SchemaElem_Leaflist
	Schema        isSchemaElem_Schema `protobuf_oneof:"schema"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SchemaElem) Reset() {
	*x = SchemaElem{}
	mi := &file_schema_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SchemaElem) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SchemaElem) ProtoMessage() {}

func (x *SchemaElem) ProtoReflect() protoreflect.Message {
	mi := &file_schema_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SchemaElem.ProtoReflect.Descriptor instead.
func (*SchemaElem) Descriptor() ([]byte, []int) {
	return file_schema_proto_rawDescGZIP(), []int{7}
}

func (x *SchemaElem) GetSchema() isSchemaElem_Schema {
	if x != nil {
		return x.Schema
	}
	return nil
}

func (x *SchemaElem) GetContainer() *ContainerSchema {
	if x != nil {
		if x, ok := x.Schema.(*SchemaElem_Container); ok {
			return x.Container
		}
	}
	return nil
}

func (x *SchemaElem) GetField() *LeafSchema {
	if x != nil {
		if x, ok := x.Schema.(*SchemaElem_Field); ok {
			return x.Field
		}
	}
	return nil
}

func (x *SchemaElem) GetLeaflist() *LeafListSchema {
	if x != nil {
		if x, ok := x.Schema.(*SchemaElem_Leaflist); ok {
			return x.Leaflist
		}
	}
	return nil
}

type isSchemaElem_Schema interface {
	isSchemaElem_Schema()
}

type SchemaElem_Container struct {
	Container *ContainerSchema `protobuf:"bytes,1,opt,name=container,proto3,oneof"`
}

type SchemaElem_Field struct {
	Field *LeafSchema `protobuf:"bytes,2,opt,name=field,proto3,oneof"`
}

type SchemaElem_Leaflist struct {
	Leaflist *LeafListSchema `protobuf:"bytes,3,opt,name=leaflist,proto3,oneof"`
}

func (*SchemaElem_Container) isSchemaElem_Schema() {}

func (*SchemaElem_Field) isSchemaElem_Schema() {}

func (*SchemaElem_Leaflist) isSchemaElem_Schema() {}

type CreateSchemaRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Schema        *Schema                `protobuf:"bytes,1,opt,name=schema,proto3" json:"schema,omitempty"` // status unset
	File          []string               `protobuf:"bytes,2,rep,name=file,proto3" json:"file,omitempty"`
	Directory     []string               `protobuf:"bytes,3,rep,name=directory,proto3" json:"directory,omitempty"`
	Exclude       []string               `protobuf:"bytes,4,rep,name=exclude,proto3" json:"exclude,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CreateSchemaRequest) Reset() {
	*x = CreateSchemaRequest{}
	mi := &file_schema_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CreateSchemaRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CreateSchemaRequest) ProtoMessage() {}

func (x *CreateSchemaRequest) ProtoReflect() protoreflect.Message {
	mi := &file_schema_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CreateSchemaRequest.ProtoReflect.Descriptor instead.
func (*CreateSchemaRequest) Descriptor() ([]byte, []int) {
	return file_schema_proto_rawDescGZIP(), []int{8}
}

func (x *CreateSchemaRequest) GetSchema() *Schema {
	if x != nil {
		return x.Schema
	}
	return nil
}

func (x *CreateSchemaRequest) GetFile() []string {
	if x != nil {
		return x.File
	}
	return nil
}

func (x *CreateSchemaRequest) GetDirectory() []string {
	if x != nil {
		return x.Directory
	}
	return nil
}

func (x *CreateSchemaRequest) GetExclude() []string {
	if x != nil {
		return x.Exclude
	}
	return nil
}

type CreateSchemaResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Schema        *Schema                `protobuf:"bytes,1,opt,name=schema,proto3" json:"schema,omitempty"` // status should be intializing
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CreateSchemaResponse) Reset() {
	*x = CreateSchemaResponse{}
	mi := &file_schema_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CreateSchemaResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CreateSchemaResponse) ProtoMessage() {}

func (x *CreateSchemaResponse) ProtoReflect() protoreflect.Message {
	mi := &file_schema_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CreateSchemaResponse.ProtoReflect.Descriptor instead.
func (*CreateSchemaResponse) Descriptor() ([]byte, []int) {
	return file_schema_proto_rawDescGZIP(), []int{9}
}

func (x *CreateSchemaResponse) GetSchema() *Schema {
	if x != nil {
		return x.Schema
	}
	return nil
}

type ReloadSchemaRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Schema        *Schema                `protobuf:"bytes,1,opt,name=schema,proto3" json:"schema,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ReloadSchemaRequest) Reset() {
	*x = ReloadSchemaRequest{}
	mi := &file_schema_proto_msgTypes[10]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ReloadSchemaRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ReloadSchemaRequest) ProtoMessage() {}

func (x *ReloadSchemaRequest) ProtoReflect() protoreflect.Message {
	mi := &file_schema_proto_msgTypes[10]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ReloadSchemaRequest.ProtoReflect.Descriptor instead.
func (*ReloadSchemaRequest) Descriptor() ([]byte, []int) {
	return file_schema_proto_rawDescGZIP(), []int{10}
}

func (x *ReloadSchemaRequest) GetSchema() *Schema {
	if x != nil {
		return x.Schema
	}
	return nil
}

type ReloadSchemaResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ReloadSchemaResponse) Reset() {
	*x = ReloadSchemaResponse{}
	mi := &file_schema_proto_msgTypes[11]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ReloadSchemaResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ReloadSchemaResponse) ProtoMessage() {}

func (x *ReloadSchemaResponse) ProtoReflect() protoreflect.Message {
	mi := &file_schema_proto_msgTypes[11]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ReloadSchemaResponse.ProtoReflect.Descriptor instead.
func (*ReloadSchemaResponse) Descriptor() ([]byte, []int) {
	return file_schema_proto_rawDescGZIP(), []int{11}
}

type DeleteSchemaRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Schema        *Schema                `protobuf:"bytes,1,opt,name=schema,proto3" json:"schema,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DeleteSchemaRequest) Reset() {
	*x = DeleteSchemaRequest{}
	mi := &file_schema_proto_msgTypes[12]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DeleteSchemaRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DeleteSchemaRequest) ProtoMessage() {}

func (x *DeleteSchemaRequest) ProtoReflect() protoreflect.Message {
	mi := &file_schema_proto_msgTypes[12]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DeleteSchemaRequest.ProtoReflect.Descriptor instead.
func (*DeleteSchemaRequest) Descriptor() ([]byte, []int) {
	return file_schema_proto_rawDescGZIP(), []int{12}
}

func (x *DeleteSchemaRequest) GetSchema() *Schema {
	if x != nil {
		return x.Schema
	}
	return nil
}

type DeleteSchemaResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DeleteSchemaResponse) Reset() {
	*x = DeleteSchemaResponse{}
	mi := &file_schema_proto_msgTypes[13]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DeleteSchemaResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DeleteSchemaResponse) ProtoMessage() {}

func (x *DeleteSchemaResponse) ProtoReflect() protoreflect.Message {
	mi := &file_schema_proto_msgTypes[13]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DeleteSchemaResponse.ProtoReflect.Descriptor instead.
func (*DeleteSchemaResponse) Descriptor() ([]byte, []int) {
	return file_schema_proto_rawDescGZIP(), []int{13}
}

type UploadSchemaRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to Upload:
	//
	//	*UploadSchemaRequest_CreateSchema
	//	*UploadSchemaRequest_SchemaFile
	//	*UploadSchemaRequest_Finalize
	Upload        isUploadSchemaRequest_Upload `protobuf_oneof:"upload"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *UploadSchemaRequest) Reset() {
	*x = UploadSchemaRequest{}
	mi := &file_schema_proto_msgTypes[14]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UploadSchemaRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UploadSchemaRequest) ProtoMessage() {}

func (x *UploadSchemaRequest) ProtoReflect() protoreflect.Message {
	mi := &file_schema_proto_msgTypes[14]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UploadSchemaRequest.ProtoReflect.Descriptor instead.
func (*UploadSchemaRequest) Descriptor() ([]byte, []int) {
	return file_schema_proto_rawDescGZIP(), []int{14}
}

func (x *UploadSchemaRequest) GetUpload() isUploadSchemaRequest_Upload {
	if x != nil {
		return x.Upload
	}
	return nil
}

func (x *UploadSchemaRequest) GetCreateSchema() *CreateSchemaRequest {
	if x != nil {
		if x, ok := x.Upload.(*UploadSchemaRequest_CreateSchema); ok {
			return x.CreateSchema
		}
	}
	return nil
}

func (x *UploadSchemaRequest) GetSchemaFile() *UploadSchemaFile {
	if x != nil {
		if x, ok := x.Upload.(*UploadSchemaRequest_SchemaFile); ok {
			return x.SchemaFile
		}
	}
	return nil
}

func (x *UploadSchemaRequest) GetFinalize() *UploadSchemaFinalize {
	if x != nil {
		if x, ok := x.Upload.(*UploadSchemaRequest_Finalize); ok {
			return x.Finalize
		}
	}
	return nil
}

type isUploadSchemaRequest_Upload interface {
	isUploadSchemaRequest_Upload()
}

type UploadSchemaRequest_CreateSchema struct {
	CreateSchema *CreateSchemaRequest `protobuf:"bytes,1,opt,name=create_schema,json=createSchema,proto3,oneof"`
}

type UploadSchemaRequest_SchemaFile struct {
	SchemaFile *UploadSchemaFile `protobuf:"bytes,2,opt,name=schema_file,json=schemaFile,proto3,oneof"`
}

type UploadSchemaRequest_Finalize struct {
	Finalize *UploadSchemaFinalize `protobuf:"bytes,3,opt,name=finalize,proto3,oneof"`
}

func (*UploadSchemaRequest_CreateSchema) isUploadSchemaRequest_Upload() {}

func (*UploadSchemaRequest_SchemaFile) isUploadSchemaRequest_Upload() {}

func (*UploadSchemaRequest_Finalize) isUploadSchemaRequest_Upload() {}

type UploadSchemaFile struct {
	state         protoimpl.MessageState    `protogen:"open.v1"`
	FileName      string                    `protobuf:"bytes,1,opt,name=file_name,json=fileName,proto3" json:"file_name,omitempty"`                                        // file name with path
	FileType      UploadSchemaFile_FileType `protobuf:"varint,2,opt,name=file_type,json=fileType,proto3,enum=schema.UploadSchemaFile_FileType" json:"file_type,omitempty"` // file
	Contents      []byte                    `protobuf:"bytes,3,opt,name=contents,proto3" json:"contents,omitempty"`                                                        // raw bytes to be appended to the file
	Hash          *Hash                     `protobuf:"bytes,4,opt,name=hash,proto3" json:"hash,omitempty"`                                                                // if present marks the last message for that file
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *UploadSchemaFile) Reset() {
	*x = UploadSchemaFile{}
	mi := &file_schema_proto_msgTypes[15]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UploadSchemaFile) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UploadSchemaFile) ProtoMessage() {}

func (x *UploadSchemaFile) ProtoReflect() protoreflect.Message {
	mi := &file_schema_proto_msgTypes[15]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UploadSchemaFile.ProtoReflect.Descriptor instead.
func (*UploadSchemaFile) Descriptor() ([]byte, []int) {
	return file_schema_proto_rawDescGZIP(), []int{15}
}

func (x *UploadSchemaFile) GetFileName() string {
	if x != nil {
		return x.FileName
	}
	return ""
}

func (x *UploadSchemaFile) GetFileType() UploadSchemaFile_FileType {
	if x != nil {
		return x.FileType
	}
	return UploadSchemaFile_MODULE
}

func (x *UploadSchemaFile) GetContents() []byte {
	if x != nil {
		return x.Contents
	}
	return nil
}

func (x *UploadSchemaFile) GetHash() *Hash {
	if x != nil {
		return x.Hash
	}
	return nil
}

type ToPathRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	PathElement   []string               `protobuf:"bytes,1,rep,name=path_element,json=pathElement,proto3" json:"path_element,omitempty"`
	Schema        *Schema                `protobuf:"bytes,2,opt,name=schema,proto3" json:"schema,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ToPathRequest) Reset() {
	*x = ToPathRequest{}
	mi := &file_schema_proto_msgTypes[16]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ToPathRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ToPathRequest) ProtoMessage() {}

func (x *ToPathRequest) ProtoReflect() protoreflect.Message {
	mi := &file_schema_proto_msgTypes[16]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ToPathRequest.ProtoReflect.Descriptor instead.
func (*ToPathRequest) Descriptor() ([]byte, []int) {
	return file_schema_proto_rawDescGZIP(), []int{16}
}

func (x *ToPathRequest) GetPathElement() []string {
	if x != nil {
		return x.PathElement
	}
	return nil
}

func (x *ToPathRequest) GetSchema() *Schema {
	if x != nil {
		return x.Schema
	}
	return nil
}

type ToPathResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Path          *Path                  `protobuf:"bytes,1,opt,name=path,proto3" json:"path,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ToPathResponse) Reset() {
	*x = ToPathResponse{}
	mi := &file_schema_proto_msgTypes[17]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ToPathResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ToPathResponse) ProtoMessage() {}

func (x *ToPathResponse) ProtoReflect() protoreflect.Message {
	mi := &file_schema_proto_msgTypes[17]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ToPathResponse.ProtoReflect.Descriptor instead.
func (*ToPathResponse) Descriptor() ([]byte, []int) {
	return file_schema_proto_rawDescGZIP(), []int{17}
}

func (x *ToPathResponse) GetPath() *Path {
	if x != nil {
		return x.Path
	}
	return nil
}

type ExpandPathRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Path          *Path                  `protobuf:"bytes,1,opt,name=path,proto3" json:"path,omitempty"`
	Schema        *Schema                `protobuf:"bytes,2,opt,name=schema,proto3" json:"schema,omitempty"`
	DataType      DataType               `protobuf:"varint,3,opt,name=data_type,json=dataType,proto3,enum=schema.DataType" json:"data_type,omitempty"`
	Xpath         bool                   `protobuf:"varint,4,opt,name=xpath,proto3" json:"xpath,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ExpandPathRequest) Reset() {
	*x = ExpandPathRequest{}
	mi := &file_schema_proto_msgTypes[18]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ExpandPathRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ExpandPathRequest) ProtoMessage() {}

func (x *ExpandPathRequest) ProtoReflect() protoreflect.Message {
	mi := &file_schema_proto_msgTypes[18]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ExpandPathRequest.ProtoReflect.Descriptor instead.
func (*ExpandPathRequest) Descriptor() ([]byte, []int) {
	return file_schema_proto_rawDescGZIP(), []int{18}
}

func (x *ExpandPathRequest) GetPath() *Path {
	if x != nil {
		return x.Path
	}
	return nil
}

func (x *ExpandPathRequest) GetSchema() *Schema {
	if x != nil {
		return x.Schema
	}
	return nil
}

func (x *ExpandPathRequest) GetDataType() DataType {
	if x != nil {
		return x.DataType
	}
	return DataType_ALL
}

func (x *ExpandPathRequest) GetXpath() bool {
	if x != nil {
		return x.Xpath
	}
	return false
}

type ExpandPathResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Path          []*Path                `protobuf:"bytes,1,rep,name=path,proto3" json:"path,omitempty"`
	Xpath         []string               `protobuf:"bytes,2,rep,name=xpath,proto3" json:"xpath,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ExpandPathResponse) Reset() {
	*x = ExpandPathResponse{}
	mi := &file_schema_proto_msgTypes[19]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ExpandPathResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ExpandPathResponse) ProtoMessage() {}

func (x *ExpandPathResponse) ProtoReflect() protoreflect.Message {
	mi := &file_schema_proto_msgTypes[19]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ExpandPathResponse.ProtoReflect.Descriptor instead.
func (*ExpandPathResponse) Descriptor() ([]byte, []int) {
	return file_schema_proto_rawDescGZIP(), []int{19}
}

func (x *ExpandPathResponse) GetPath() []*Path {
	if x != nil {
		return x.Path
	}
	return nil
}

func (x *ExpandPathResponse) GetXpath() []string {
	if x != nil {
		return x.Xpath
	}
	return nil
}

type Hash struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Method        Hash_HashMethod        `protobuf:"varint,1,opt,name=method,proto3,enum=schema.Hash_HashMethod" json:"method,omitempty"`
	Hash          []byte                 `protobuf:"bytes,2,opt,name=hash,proto3" json:"hash,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Hash) Reset() {
	*x = Hash{}
	mi := &file_schema_proto_msgTypes[20]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Hash) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Hash) ProtoMessage() {}

func (x *Hash) ProtoReflect() protoreflect.Message {
	mi := &file_schema_proto_msgTypes[20]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Hash.ProtoReflect.Descriptor instead.
func (*Hash) Descriptor() ([]byte, []int) {
	return file_schema_proto_rawDescGZIP(), []int{20}
}

func (x *Hash) GetMethod() Hash_HashMethod {
	if x != nil {
		return x.Method
	}
	return Hash_UNSPECIFIED
}

func (x *Hash) GetHash() []byte {
	if x != nil {
		return x.Hash
	}
	return nil
}

type UploadSchemaFinalize struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *UploadSchemaFinalize) Reset() {
	*x = UploadSchemaFinalize{}
	mi := &file_schema_proto_msgTypes[21]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UploadSchemaFinalize) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UploadSchemaFinalize) ProtoMessage() {}

func (x *UploadSchemaFinalize) ProtoReflect() protoreflect.Message {
	mi := &file_schema_proto_msgTypes[21]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UploadSchemaFinalize.ProtoReflect.Descriptor instead.
func (*UploadSchemaFinalize) Descriptor() ([]byte, []int) {
	return file_schema_proto_rawDescGZIP(), []int{21}
}

type UploadSchemaResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *UploadSchemaResponse) Reset() {
	*x = UploadSchemaResponse{}
	mi := &file_schema_proto_msgTypes[22]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UploadSchemaResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UploadSchemaResponse) ProtoMessage() {}

func (x *UploadSchemaResponse) ProtoReflect() protoreflect.Message {
	mi := &file_schema_proto_msgTypes[22]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UploadSchemaResponse.ProtoReflect.Descriptor instead.
func (*UploadSchemaResponse) Descriptor() ([]byte, []int) {
	return file_schema_proto_rawDescGZIP(), []int{22}
}

// sub messages
type ContainerSchema struct {
	state              protoimpl.MessageState `protogen:"open.v1"`
	Name               string                 `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Description        string                 `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	Owner              string                 `protobuf:"bytes,3,opt,name=owner,proto3" json:"owner,omitempty"`
	Namespace          string                 `protobuf:"bytes,4,opt,name=namespace,proto3" json:"namespace,omitempty"`
	Prefix             string                 `protobuf:"bytes,5,opt,name=prefix,proto3" json:"prefix,omitempty"`
	Keys               []*LeafSchema          `protobuf:"bytes,6,rep,name=keys,proto3" json:"keys,omitempty"`
	Fields             []*LeafSchema          `protobuf:"bytes,7,rep,name=fields,proto3" json:"fields,omitempty"`
	Leaflists          []*LeafListSchema      `protobuf:"bytes,8,rep,name=leaflists,proto3" json:"leaflists,omitempty"`
	Children           []string               `protobuf:"bytes,9,rep,name=children,proto3" json:"children,omitempty"`
	MandatoryChildren  []*MandatoryChild      `protobuf:"bytes,10,rep,name=mandatory_children,json=mandatoryChildren,proto3" json:"mandatory_children,omitempty"`
	MustStatements     []*MustStatement       `protobuf:"bytes,11,rep,name=must_statements,json=mustStatements,proto3" json:"must_statements,omitempty"`
	ModuleName         string                 `protobuf:"bytes,12,opt,name=module_name,json=moduleName,proto3" json:"module_name,omitempty"`
	MaxElements        uint64                 `protobuf:"varint,13,opt,name=max_elements,json=maxElements,proto3" json:"max_elements,omitempty"`
	MinElements        uint64                 `protobuf:"varint,14,opt,name=min_elements,json=minElements,proto3" json:"min_elements,omitempty"`
	ChildsWithDefaults []string               `protobuf:"bytes,15,rep,name=childs_with_defaults,json=childsWithDefaults,proto3" json:"childs_with_defaults,omitempty"`
	IsPresence         bool                   `protobuf:"varint,20,opt,name=is_presence,json=isPresence,proto3" json:"is_presence,omitempty"`
	IsState            bool                   `protobuf:"varint,21,opt,name=is_state,json=isState,proto3" json:"is_state,omitempty"`
	IsUserOrdered      bool                   `protobuf:"varint,22,opt,name=is_user_ordered,json=isUserOrdered,proto3" json:"is_user_ordered,omitempty"`
	IfFeature          []string               `protobuf:"bytes,23,rep,name=if_feature,json=ifFeature,proto3" json:"if_feature,omitempty"`
	ChoiceInfo         *ChoiceInfo            `protobuf:"bytes,30,opt,name=choice_info,json=choiceInfo,proto3" json:"choice_info,omitempty"`
	unknownFields      protoimpl.UnknownFields
	sizeCache          protoimpl.SizeCache
}

func (x *ContainerSchema) Reset() {
	*x = ContainerSchema{}
	mi := &file_schema_proto_msgTypes[23]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ContainerSchema) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ContainerSchema) ProtoMessage() {}

func (x *ContainerSchema) ProtoReflect() protoreflect.Message {
	mi := &file_schema_proto_msgTypes[23]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ContainerSchema.ProtoReflect.Descriptor instead.
func (*ContainerSchema) Descriptor() ([]byte, []int) {
	return file_schema_proto_rawDescGZIP(), []int{23}
}

func (x *ContainerSchema) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *ContainerSchema) GetDescription() string {
	if x != nil {
		return x.Description
	}
	return ""
}

func (x *ContainerSchema) GetOwner() string {
	if x != nil {
		return x.Owner
	}
	return ""
}

func (x *ContainerSchema) GetNamespace() string {
	if x != nil {
		return x.Namespace
	}
	return ""
}

func (x *ContainerSchema) GetPrefix() string {
	if x != nil {
		return x.Prefix
	}
	return ""
}

func (x *ContainerSchema) GetKeys() []*LeafSchema {
	if x != nil {
		return x.Keys
	}
	return nil
}

func (x *ContainerSchema) GetFields() []*LeafSchema {
	if x != nil {
		return x.Fields
	}
	return nil
}

func (x *ContainerSchema) GetLeaflists() []*LeafListSchema {
	if x != nil {
		return x.Leaflists
	}
	return nil
}

func (x *ContainerSchema) GetChildren() []string {
	if x != nil {
		return x.Children
	}
	return nil
}

func (x *ContainerSchema) GetMandatoryChildren() []*MandatoryChild {
	if x != nil {
		return x.MandatoryChildren
	}
	return nil
}

func (x *ContainerSchema) GetMustStatements() []*MustStatement {
	if x != nil {
		return x.MustStatements
	}
	return nil
}

func (x *ContainerSchema) GetModuleName() string {
	if x != nil {
		return x.ModuleName
	}
	return ""
}

func (x *ContainerSchema) GetMaxElements() uint64 {
	if x != nil {
		return x.MaxElements
	}
	return 0
}

func (x *ContainerSchema) GetMinElements() uint64 {
	if x != nil {
		return x.MinElements
	}
	return 0
}

func (x *ContainerSchema) GetChildsWithDefaults() []string {
	if x != nil {
		return x.ChildsWithDefaults
	}
	return nil
}

func (x *ContainerSchema) GetIsPresence() bool {
	if x != nil {
		return x.IsPresence
	}
	return false
}

func (x *ContainerSchema) GetIsState() bool {
	if x != nil {
		return x.IsState
	}
	return false
}

func (x *ContainerSchema) GetIsUserOrdered() bool {
	if x != nil {
		return x.IsUserOrdered
	}
	return false
}

func (x *ContainerSchema) GetIfFeature() []string {
	if x != nil {
		return x.IfFeature
	}
	return nil
}

func (x *ContainerSchema) GetChoiceInfo() *ChoiceInfo {
	if x != nil {
		return x.ChoiceInfo
	}
	return nil
}

type MandatoryChild struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Name          string                 `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	IsState       bool                   `protobuf:"varint,2,opt,name=is_state,json=isState,proto3" json:"is_state,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *MandatoryChild) Reset() {
	*x = MandatoryChild{}
	mi := &file_schema_proto_msgTypes[24]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *MandatoryChild) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MandatoryChild) ProtoMessage() {}

func (x *MandatoryChild) ProtoReflect() protoreflect.Message {
	mi := &file_schema_proto_msgTypes[24]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MandatoryChild.ProtoReflect.Descriptor instead.
func (*MandatoryChild) Descriptor() ([]byte, []int) {
	return file_schema_proto_rawDescGZIP(), []int{24}
}

func (x *MandatoryChild) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *MandatoryChild) GetIsState() bool {
	if x != nil {
		return x.IsState
	}
	return false
}

type LeafListSchema struct {
	state          protoimpl.MessageState `protogen:"open.v1"`
	Name           string                 `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Description    string                 `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	Owner          string                 `protobuf:"bytes,3,opt,name=owner,proto3" json:"owner,omitempty"`
	Namespace      string                 `protobuf:"bytes,4,opt,name=namespace,proto3" json:"namespace,omitempty"`
	Prefix         string                 `protobuf:"bytes,5,opt,name=prefix,proto3" json:"prefix,omitempty"`
	Type           *SchemaLeafType        `protobuf:"bytes,6,opt,name=type,proto3" json:"type,omitempty"`
	Encrypted      bool                   `protobuf:"varint,7,opt,name=encrypted,proto3" json:"encrypted,omitempty"`
	ModuleName     string                 `protobuf:"bytes,8,opt,name=module_name,json=moduleName,proto3" json:"module_name,omitempty"`
	Units          string                 `protobuf:"bytes,9,opt,name=units,proto3" json:"units,omitempty"`
	MustStatements []*MustStatement       `protobuf:"bytes,11,rep,name=must_statements,json=mustStatements,proto3" json:"must_statements,omitempty"`
	Defaults       []string               `protobuf:"bytes,12,rep,name=defaults,proto3" json:"defaults,omitempty"`
	MaxElements    uint64                 `protobuf:"varint,13,opt,name=max_elements,json=maxElements,proto3" json:"max_elements,omitempty"`
	MinElements    uint64                 `protobuf:"varint,14,opt,name=min_elements,json=minElements,proto3" json:"min_elements,omitempty"`
	IsState        bool                   `protobuf:"varint,21,opt,name=is_state,json=isState,proto3" json:"is_state,omitempty"`
	IsUserOrdered  bool                   `protobuf:"varint,22,opt,name=is_user_ordered,json=isUserOrdered,proto3" json:"is_user_ordered,omitempty"`
	IfFeature      []string               `protobuf:"bytes,23,rep,name=if_feature,json=ifFeature,proto3" json:"if_feature,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *LeafListSchema) Reset() {
	*x = LeafListSchema{}
	mi := &file_schema_proto_msgTypes[25]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *LeafListSchema) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*LeafListSchema) ProtoMessage() {}

func (x *LeafListSchema) ProtoReflect() protoreflect.Message {
	mi := &file_schema_proto_msgTypes[25]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use LeafListSchema.ProtoReflect.Descriptor instead.
func (*LeafListSchema) Descriptor() ([]byte, []int) {
	return file_schema_proto_rawDescGZIP(), []int{25}
}

func (x *LeafListSchema) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *LeafListSchema) GetDescription() string {
	if x != nil {
		return x.Description
	}
	return ""
}

func (x *LeafListSchema) GetOwner() string {
	if x != nil {
		return x.Owner
	}
	return ""
}

func (x *LeafListSchema) GetNamespace() string {
	if x != nil {
		return x.Namespace
	}
	return ""
}

func (x *LeafListSchema) GetPrefix() string {
	if x != nil {
		return x.Prefix
	}
	return ""
}

func (x *LeafListSchema) GetType() *SchemaLeafType {
	if x != nil {
		return x.Type
	}
	return nil
}

func (x *LeafListSchema) GetEncrypted() bool {
	if x != nil {
		return x.Encrypted
	}
	return false
}

func (x *LeafListSchema) GetModuleName() string {
	if x != nil {
		return x.ModuleName
	}
	return ""
}

func (x *LeafListSchema) GetUnits() string {
	if x != nil {
		return x.Units
	}
	return ""
}

func (x *LeafListSchema) GetMustStatements() []*MustStatement {
	if x != nil {
		return x.MustStatements
	}
	return nil
}

func (x *LeafListSchema) GetDefaults() []string {
	if x != nil {
		return x.Defaults
	}
	return nil
}

func (x *LeafListSchema) GetMaxElements() uint64 {
	if x != nil {
		return x.MaxElements
	}
	return 0
}

func (x *LeafListSchema) GetMinElements() uint64 {
	if x != nil {
		return x.MinElements
	}
	return 0
}

func (x *LeafListSchema) GetIsState() bool {
	if x != nil {
		return x.IsState
	}
	return false
}

func (x *LeafListSchema) GetIsUserOrdered() bool {
	if x != nil {
		return x.IsUserOrdered
	}
	return false
}

func (x *LeafListSchema) GetIfFeature() []string {
	if x != nil {
		return x.IfFeature
	}
	return nil
}

type LeafSchema struct {
	state          protoimpl.MessageState `protogen:"open.v1"`
	Name           string                 `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Description    string                 `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	Owner          string                 `protobuf:"bytes,3,opt,name=owner,proto3" json:"owner,omitempty"`
	Namespace      string                 `protobuf:"bytes,4,opt,name=namespace,proto3" json:"namespace,omitempty"`
	Prefix         string                 `protobuf:"bytes,5,opt,name=prefix,proto3" json:"prefix,omitempty"`
	Type           *SchemaLeafType        `protobuf:"bytes,6,opt,name=type,proto3" json:"type,omitempty"`
	Encrypted      bool                   `protobuf:"varint,7,opt,name=encrypted,proto3" json:"encrypted,omitempty"`
	IsMandatory    bool                   `protobuf:"varint,8,opt,name=is_mandatory,json=isMandatory,proto3" json:"is_mandatory,omitempty"`
	Units          string                 `protobuf:"bytes,9,opt,name=units,proto3" json:"units,omitempty"`
	ModuleName     string                 `protobuf:"bytes,10,opt,name=module_name,json=moduleName,proto3" json:"module_name,omitempty"`
	MustStatements []*MustStatement       `protobuf:"bytes,11,rep,name=must_statements,json=mustStatements,proto3" json:"must_statements,omitempty"`
	Default        string                 `protobuf:"bytes,12,opt,name=default,proto3" json:"default,omitempty"`
	IsState        bool                   `protobuf:"varint,21,opt,name=is_state,json=isState,proto3" json:"is_state,omitempty"`
	IfFeature      []string               `protobuf:"bytes,23,rep,name=if_feature,json=ifFeature,proto3" json:"if_feature,omitempty"`
	Reference      []string               `protobuf:"bytes,25,rep,name=reference,proto3" json:"reference,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *LeafSchema) Reset() {
	*x = LeafSchema{}
	mi := &file_schema_proto_msgTypes[26]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *LeafSchema) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*LeafSchema) ProtoMessage() {}

func (x *LeafSchema) ProtoReflect() protoreflect.Message {
	mi := &file_schema_proto_msgTypes[26]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use LeafSchema.ProtoReflect.Descriptor instead.
func (*LeafSchema) Descriptor() ([]byte, []int) {
	return file_schema_proto_rawDescGZIP(), []int{26}
}

func (x *LeafSchema) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *LeafSchema) GetDescription() string {
	if x != nil {
		return x.Description
	}
	return ""
}

func (x *LeafSchema) GetOwner() string {
	if x != nil {
		return x.Owner
	}
	return ""
}

func (x *LeafSchema) GetNamespace() string {
	if x != nil {
		return x.Namespace
	}
	return ""
}

func (x *LeafSchema) GetPrefix() string {
	if x != nil {
		return x.Prefix
	}
	return ""
}

func (x *LeafSchema) GetType() *SchemaLeafType {
	if x != nil {
		return x.Type
	}
	return nil
}

func (x *LeafSchema) GetEncrypted() bool {
	if x != nil {
		return x.Encrypted
	}
	return false
}

func (x *LeafSchema) GetIsMandatory() bool {
	if x != nil {
		return x.IsMandatory
	}
	return false
}

func (x *LeafSchema) GetUnits() string {
	if x != nil {
		return x.Units
	}
	return ""
}

func (x *LeafSchema) GetModuleName() string {
	if x != nil {
		return x.ModuleName
	}
	return ""
}

func (x *LeafSchema) GetMustStatements() []*MustStatement {
	if x != nil {
		return x.MustStatements
	}
	return nil
}

func (x *LeafSchema) GetDefault() string {
	if x != nil {
		return x.Default
	}
	return ""
}

func (x *LeafSchema) GetIsState() bool {
	if x != nil {
		return x.IsState
	}
	return false
}

func (x *LeafSchema) GetIfFeature() []string {
	if x != nil {
		return x.IfFeature
	}
	return nil
}

func (x *LeafSchema) GetReference() []string {
	if x != nil {
		return x.Reference
	}
	return nil
}

type SchemaLeafType struct {
	state     protoimpl.MessageState `protogen:"open.v1"`
	Type      string                 `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty"`
	Range     []*SchemaMinMaxType    `protobuf:"bytes,2,rep,name=range,proto3" json:"range,omitempty"`
	Length    []*SchemaMinMaxType    `protobuf:"bytes,3,rep,name=length,proto3" json:"length,omitempty"`
	EnumNames []string               `protobuf:"bytes,4,rep,name=enum_names,json=enumNames,proto3" json:"enum_names,omitempty"`
	Units     string                 `protobuf:"bytes,5,opt,name=units,proto3" json:"units,omitempty"`
	TypeName  string                 `protobuf:"bytes,6,opt,name=type_name,json=typeName,proto3" json:"type_name,omitempty"`
	Leafref   string                 `protobuf:"bytes,7,opt,name=leafref,proto3" json:"leafref,omitempty"`
	// optional_instance defines for a leafref if the referenced leaf needs to
	// exist or not.
	OptionalInstance    bool              `protobuf:"varint,8,opt,name=optional_instance,json=optionalInstance,proto3" json:"optional_instance,omitempty"`
	Patterns            []*SchemaPattern  `protobuf:"bytes,9,rep,name=patterns,proto3" json:"patterns,omitempty"`
	UnionTypes          []*SchemaLeafType `protobuf:"bytes,10,rep,name=union_types,json=unionTypes,proto3" json:"union_types,omitempty"`
	IdentityPrefixesMap map[string]string `protobuf:"bytes,11,rep,name=identity_prefixes_map,json=identityPrefixesMap,proto3" json:"identity_prefixes_map,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	ModulePrefixMap     map[string]string `protobuf:"bytes,12,rep,name=module_prefix_map,json=modulePrefixMap,proto3" json:"module_prefix_map,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	LeafrefTargetType   *SchemaLeafType   `protobuf:"bytes,13,opt,name=leafref_target_type,json=leafrefTargetType,proto3" json:"leafref_target_type,omitempty"`
	Bits                []*Bit            `protobuf:"bytes,14,rep,name=bits,proto3" json:"bits,omitempty"`
	unknownFields       protoimpl.UnknownFields
	sizeCache           protoimpl.SizeCache
}

func (x *SchemaLeafType) Reset() {
	*x = SchemaLeafType{}
	mi := &file_schema_proto_msgTypes[27]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SchemaLeafType) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SchemaLeafType) ProtoMessage() {}

func (x *SchemaLeafType) ProtoReflect() protoreflect.Message {
	mi := &file_schema_proto_msgTypes[27]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SchemaLeafType.ProtoReflect.Descriptor instead.
func (*SchemaLeafType) Descriptor() ([]byte, []int) {
	return file_schema_proto_rawDescGZIP(), []int{27}
}

func (x *SchemaLeafType) GetType() string {
	if x != nil {
		return x.Type
	}
	return ""
}

func (x *SchemaLeafType) GetRange() []*SchemaMinMaxType {
	if x != nil {
		return x.Range
	}
	return nil
}

func (x *SchemaLeafType) GetLength() []*SchemaMinMaxType {
	if x != nil {
		return x.Length
	}
	return nil
}

func (x *SchemaLeafType) GetEnumNames() []string {
	if x != nil {
		return x.EnumNames
	}
	return nil
}

func (x *SchemaLeafType) GetUnits() string {
	if x != nil {
		return x.Units
	}
	return ""
}

func (x *SchemaLeafType) GetTypeName() string {
	if x != nil {
		return x.TypeName
	}
	return ""
}

func (x *SchemaLeafType) GetLeafref() string {
	if x != nil {
		return x.Leafref
	}
	return ""
}

func (x *SchemaLeafType) GetOptionalInstance() bool {
	if x != nil {
		return x.OptionalInstance
	}
	return false
}

func (x *SchemaLeafType) GetPatterns() []*SchemaPattern {
	if x != nil {
		return x.Patterns
	}
	return nil
}

func (x *SchemaLeafType) GetUnionTypes() []*SchemaLeafType {
	if x != nil {
		return x.UnionTypes
	}
	return nil
}

func (x *SchemaLeafType) GetIdentityPrefixesMap() map[string]string {
	if x != nil {
		return x.IdentityPrefixesMap
	}
	return nil
}

func (x *SchemaLeafType) GetModulePrefixMap() map[string]string {
	if x != nil {
		return x.ModulePrefixMap
	}
	return nil
}

func (x *SchemaLeafType) GetLeafrefTargetType() *SchemaLeafType {
	if x != nil {
		return x.LeafrefTargetType
	}
	return nil
}

func (x *SchemaLeafType) GetBits() []*Bit {
	if x != nil {
		return x.Bits
	}
	return nil
}

type MustStatement struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Statement     string                 `protobuf:"bytes,1,opt,name=statement,proto3" json:"statement,omitempty"`
	Error         string                 `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *MustStatement) Reset() {
	*x = MustStatement{}
	mi := &file_schema_proto_msgTypes[28]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *MustStatement) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MustStatement) ProtoMessage() {}

func (x *MustStatement) ProtoReflect() protoreflect.Message {
	mi := &file_schema_proto_msgTypes[28]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MustStatement.ProtoReflect.Descriptor instead.
func (*MustStatement) Descriptor() ([]byte, []int) {
	return file_schema_proto_rawDescGZIP(), []int{28}
}

func (x *MustStatement) GetStatement() string {
	if x != nil {
		return x.Statement
	}
	return ""
}

func (x *MustStatement) GetError() string {
	if x != nil {
		return x.Error
	}
	return ""
}

type PathElem struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The name of the element in the path.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Map of key (attribute) name to value.
	Key           map[string]string `protobuf:"bytes,2,rep,name=key,proto3" json:"key,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PathElem) Reset() {
	*x = PathElem{}
	mi := &file_schema_proto_msgTypes[29]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PathElem) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PathElem) ProtoMessage() {}

func (x *PathElem) ProtoReflect() protoreflect.Message {
	mi := &file_schema_proto_msgTypes[29]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PathElem.ProtoReflect.Descriptor instead.
func (*PathElem) Descriptor() ([]byte, []int) {
	return file_schema_proto_rawDescGZIP(), []int{29}
}

func (x *PathElem) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *PathElem) GetKey() map[string]string {
	if x != nil {
		return x.Key
	}
	return nil
}

type Path struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Origin        string                 `protobuf:"bytes,2,opt,name=origin,proto3" json:"origin,omitempty"`
	Elem          []*PathElem            `protobuf:"bytes,3,rep,name=elem,proto3" json:"elem,omitempty"`
	Target        string                 `protobuf:"bytes,4,opt,name=target,proto3" json:"target,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Path) Reset() {
	*x = Path{}
	mi := &file_schema_proto_msgTypes[30]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Path) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Path) ProtoMessage() {}

func (x *Path) ProtoReflect() protoreflect.Message {
	mi := &file_schema_proto_msgTypes[30]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Path.ProtoReflect.Descriptor instead.
func (*Path) Descriptor() ([]byte, []int) {
	return file_schema_proto_rawDescGZIP(), []int{30}
}

func (x *Path) GetOrigin() string {
	if x != nil {
		return x.Origin
	}
	return ""
}

func (x *Path) GetElem() []*PathElem {
	if x != nil {
		return x.Elem
	}
	return nil
}

func (x *Path) GetTarget() string {
	if x != nil {
		return x.Target
	}
	return ""
}

type SchemaPattern struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Pattern       string                 `protobuf:"bytes,1,opt,name=pattern,proto3" json:"pattern,omitempty"`
	Inverted      bool                   `protobuf:"varint,2,opt,name=inverted,proto3" json:"inverted,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SchemaPattern) Reset() {
	*x = SchemaPattern{}
	mi := &file_schema_proto_msgTypes[31]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SchemaPattern) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SchemaPattern) ProtoMessage() {}

func (x *SchemaPattern) ProtoReflect() protoreflect.Message {
	mi := &file_schema_proto_msgTypes[31]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SchemaPattern.ProtoReflect.Descriptor instead.
func (*SchemaPattern) Descriptor() ([]byte, []int) {
	return file_schema_proto_rawDescGZIP(), []int{31}
}

func (x *SchemaPattern) GetPattern() string {
	if x != nil {
		return x.Pattern
	}
	return ""
}

func (x *SchemaPattern) GetInverted() bool {
	if x != nil {
		return x.Inverted
	}
	return false
}

type SchemaMinMaxType struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Min           *Number                `protobuf:"bytes,1,opt,name=min,proto3" json:"min,omitempty"`
	Max           *Number                `protobuf:"bytes,2,opt,name=max,proto3" json:"max,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SchemaMinMaxType) Reset() {
	*x = SchemaMinMaxType{}
	mi := &file_schema_proto_msgTypes[32]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SchemaMinMaxType) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SchemaMinMaxType) ProtoMessage() {}

func (x *SchemaMinMaxType) ProtoReflect() protoreflect.Message {
	mi := &file_schema_proto_msgTypes[32]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SchemaMinMaxType.ProtoReflect.Descriptor instead.
func (*SchemaMinMaxType) Descriptor() ([]byte, []int) {
	return file_schema_proto_rawDescGZIP(), []int{32}
}

func (x *SchemaMinMaxType) GetMin() *Number {
	if x != nil {
		return x.Min
	}
	return nil
}

func (x *SchemaMinMaxType) GetMax() *Number {
	if x != nil {
		return x.Max
	}
	return nil
}

type Number struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Value         uint64                 `protobuf:"varint,1,opt,name=value,proto3" json:"value,omitempty"`
	Negative      bool                   `protobuf:"varint,2,opt,name=negative,proto3" json:"negative,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Number) Reset() {
	*x = Number{}
	mi := &file_schema_proto_msgTypes[33]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Number) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Number) ProtoMessage() {}

func (x *Number) ProtoReflect() protoreflect.Message {
	mi := &file_schema_proto_msgTypes[33]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Number.ProtoReflect.Descriptor instead.
func (*Number) Descriptor() ([]byte, []int) {
	return file_schema_proto_rawDescGZIP(), []int{33}
}

func (x *Number) GetValue() uint64 {
	if x != nil {
		return x.Value
	}
	return 0
}

func (x *Number) GetNegative() bool {
	if x != nil {
		return x.Negative
	}
	return false
}

type Bit struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	Name  string                 `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// https://datatracker.ietf.org/doc/html/rfc7950#section-9.7.4.2
	// max is 4294967295 == 2^32-1 -> 32 bit uint
	Position      uint32 `protobuf:"varint,2,opt,name=position,proto3" json:"position,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Bit) Reset() {
	*x = Bit{}
	mi := &file_schema_proto_msgTypes[34]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Bit) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Bit) ProtoMessage() {}

func (x *Bit) ProtoReflect() protoreflect.Message {
	mi := &file_schema_proto_msgTypes[34]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Bit.ProtoReflect.Descriptor instead.
func (*Bit) Descriptor() ([]byte, []int) {
	return file_schema_proto_rawDescGZIP(), []int{34}
}

func (x *Bit) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *Bit) GetPosition() uint32 {
	if x != nil {
		return x.Position
	}
	return 0
}

type ChoiceInfo struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// If the schema object (container, field, leaf-list)
	// is a case substatement
	// this attribute will hold
	// the choice statement name
	Choice        map[string]*ChoiceInfoChoice `protobuf:"bytes,1,rep,name=choice,proto3" json:"choice,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ChoiceInfo) Reset() {
	*x = ChoiceInfo{}
	mi := &file_schema_proto_msgTypes[35]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ChoiceInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ChoiceInfo) ProtoMessage() {}

func (x *ChoiceInfo) ProtoReflect() protoreflect.Message {
	mi := &file_schema_proto_msgTypes[35]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ChoiceInfo.ProtoReflect.Descriptor instead.
func (*ChoiceInfo) Descriptor() ([]byte, []int) {
	return file_schema_proto_rawDescGZIP(), []int{35}
}

func (x *ChoiceInfo) GetChoice() map[string]*ChoiceInfoChoice {
	if x != nil {
		return x.Choice
	}
	return nil
}

type ChoiceInfoChoice struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Case          map[string]*ChoiceCase `protobuf:"bytes,1,rep,name=case,proto3" json:"case,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ChoiceInfoChoice) Reset() {
	*x = ChoiceInfoChoice{}
	mi := &file_schema_proto_msgTypes[36]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ChoiceInfoChoice) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ChoiceInfoChoice) ProtoMessage() {}

func (x *ChoiceInfoChoice) ProtoReflect() protoreflect.Message {
	mi := &file_schema_proto_msgTypes[36]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ChoiceInfoChoice.ProtoReflect.Descriptor instead.
func (*ChoiceInfoChoice) Descriptor() ([]byte, []int) {
	return file_schema_proto_rawDescGZIP(), []int{36}
}

func (x *ChoiceInfoChoice) GetCase() map[string]*ChoiceCase {
	if x != nil {
		return x.Case
	}
	return nil
}

type ChoiceCase struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Elements      []string               `protobuf:"bytes,1,rep,name=elements,proto3" json:"elements,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ChoiceCase) Reset() {
	*x = ChoiceCase{}
	mi := &file_schema_proto_msgTypes[37]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ChoiceCase) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ChoiceCase) ProtoMessage() {}

func (x *ChoiceCase) ProtoReflect() protoreflect.Message {
	mi := &file_schema_proto_msgTypes[37]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ChoiceCase.ProtoReflect.Descriptor instead.
func (*ChoiceCase) Descriptor() ([]byte, []int) {
	return file_schema_proto_rawDescGZIP(), []int{37}
}

func (x *ChoiceCase) GetElements() []string {
	if x != nil {
		return x.Elements
	}
	return nil
}

var File_schema_proto protoreflect.FileDescriptor

const file_schema_proto_rawDesc = "" +
	"\n" +
	"\fschema.proto\x12\x06schema\"|\n" +
	"\x06Schema\x12\x12\n" +
	"\x04name\x18\x02 \x01(\tR\x04name\x12\x16\n" +
	"\x06vendor\x18\x03 \x01(\tR\x06vendor\x12\x18\n" +
	"\aversion\x18\x04 \x01(\tR\aversion\x12,\n" +
	"\x06status\x18\x05 \x01(\x0e2\x14.schema.SchemaStatusR\x06status\"A\n" +
	"\x17GetSchemaDetailsRequest\x12&\n" +
	"\x06schema\x18\x01 \x01(\v2\x0e.schema.SchemaR\x06schema\"\x8e\x01\n" +
	"\x18GetSchemaDetailsResponse\x12&\n" +
	"\x06schema\x18\x01 \x01(\v2\x0e.schema.SchemaR\x06schema\x12\x12\n" +
	"\x04file\x18\x02 \x03(\tR\x04file\x12\x1c\n" +
	"\tdirectory\x18\x03 \x03(\tR\tdirectory\x12\x18\n" +
	"\aexclude\x18\x04 \x03(\tR\aexclude\"\x13\n" +
	"\x11ListSchemaRequest\"<\n" +
	"\x12ListSchemaResponse\x12&\n" +
	"\x06schema\x18\x01 \x03(\v2\x0e.schema.SchemaR\x06schema\"\xac\x01\n" +
	"\x10GetSchemaRequest\x12 \n" +
	"\x04path\x18\x01 \x01(\v2\f.schema.PathR\x04path\x12&\n" +
	"\x06schema\x18\x02 \x01(\v2\x0e.schema.SchemaR\x06schema\x12#\n" +
	"\rvalidate_keys\x18\x03 \x01(\bR\fvalidateKeys\x12)\n" +
	"\x10with_description\x18\x04 \x01(\bR\x0fwithDescription\"?\n" +
	"\x11GetSchemaResponse\x12*\n" +
	"\x06schema\x18\x01 \x01(\v2\x12.schema.SchemaElemR\x06schema\"\xb1\x01\n" +
	"\n" +
	"SchemaElem\x127\n" +
	"\tcontainer\x18\x01 \x01(\v2\x17.schema.ContainerSchemaH\x00R\tcontainer\x12*\n" +
	"\x05field\x18\x02 \x01(\v2\x12.schema.LeafSchemaH\x00R\x05field\x124\n" +
	"\bleaflist\x18\x03 \x01(\v2\x16.schema.LeafListSchemaH\x00R\bleaflistB\b\n" +
	"\x06schema\"\x89\x01\n" +
	"\x13CreateSchemaRequest\x12&\n" +
	"\x06schema\x18\x01 \x01(\v2\x0e.schema.SchemaR\x06schema\x12\x12\n" +
	"\x04file\x18\x02 \x03(\tR\x04file\x12\x1c\n" +
	"\tdirectory\x18\x03 \x03(\tR\tdirectory\x12\x18\n" +
	"\aexclude\x18\x04 \x03(\tR\aexclude\">\n" +
	"\x14CreateSchemaResponse\x12&\n" +
	"\x06schema\x18\x01 \x01(\v2\x0e.schema.SchemaR\x06schema\"=\n" +
	"\x13ReloadSchemaRequest\x12&\n" +
	"\x06schema\x18\x01 \x01(\v2\x0e.schema.SchemaR\x06schema\"\x16\n" +
	"\x14ReloadSchemaResponse\"=\n" +
	"\x13DeleteSchemaRequest\x12&\n" +
	"\x06schema\x18\x01 \x01(\v2\x0e.schema.SchemaR\x06schema\"\x16\n" +
	"\x14DeleteSchemaResponse\"\xdc\x01\n" +
	"\x13UploadSchemaRequest\x12B\n" +
	"\rcreate_schema\x18\x01 \x01(\v2\x1b.schema.CreateSchemaRequestH\x00R\fcreateSchema\x12;\n" +
	"\vschema_file\x18\x02 \x01(\v2\x18.schema.UploadSchemaFileH\x00R\n" +
	"schemaFile\x12:\n" +
	"\bfinalize\x18\x03 \x01(\v2\x1c.schema.UploadSchemaFinalizeH\x00R\bfinalizeB\b\n" +
	"\x06upload\"\xd5\x01\n" +
	"\x10UploadSchemaFile\x12\x1b\n" +
	"\tfile_name\x18\x01 \x01(\tR\bfileName\x12>\n" +
	"\tfile_type\x18\x02 \x01(\x0e2!.schema.UploadSchemaFile.FileTypeR\bfileType\x12\x1a\n" +
	"\bcontents\x18\x03 \x01(\fR\bcontents\x12 \n" +
	"\x04hash\x18\x04 \x01(\v2\f.schema.HashR\x04hash\"&\n" +
	"\bFileType\x12\n" +
	"\n" +
	"\x06MODULE\x10\x00\x12\x0e\n" +
	"\n" +
	"DEPENDENCY\x10\x01\"Z\n" +
	"\rToPathRequest\x12!\n" +
	"\fpath_element\x18\x01 \x03(\tR\vpathElement\x12&\n" +
	"\x06schema\x18\x02 \x01(\v2\x0e.schema.SchemaR\x06schema\"2\n" +
	"\x0eToPathResponse\x12 \n" +
	"\x04path\x18\x01 \x01(\v2\f.schema.PathR\x04path\"\xa2\x01\n" +
	"\x11ExpandPathRequest\x12 \n" +
	"\x04path\x18\x01 \x01(\v2\f.schema.PathR\x04path\x12&\n" +
	"\x06schema\x18\x02 \x01(\v2\x0e.schema.SchemaR\x06schema\x12-\n" +
	"\tdata_type\x18\x03 \x01(\x0e2\x10.schema.DataTypeR\bdataType\x12\x14\n" +
	"\x05xpath\x18\x04 \x01(\bR\x05xpath\"L\n" +
	"\x12ExpandPathResponse\x12 \n" +
	"\x04path\x18\x01 \x03(\v2\f.schema.PathR\x04path\x12\x14\n" +
	"\x05xpath\x18\x02 \x03(\tR\x05xpath\"\x8b\x01\n" +
	"\x04Hash\x12/\n" +
	"\x06method\x18\x01 \x01(\x0e2\x17.schema.Hash.HashMethodR\x06method\x12\x12\n" +
	"\x04hash\x18\x02 \x01(\fR\x04hash\">\n" +
	"\n" +
	"HashMethod\x12\x0f\n" +
	"\vUNSPECIFIED\x10\x00\x12\a\n" +
	"\x03MD5\x10\x01\x12\n" +
	"\n" +
	"\x06SHA256\x10\x02\x12\n" +
	"\n" +
	"\x06SHA512\x10\x03\"\x16\n" +
	"\x14UploadSchemaFinalize\"\x16\n" +
	"\x14UploadSchemaResponse\"\x91\x06\n" +
	"\x0fContainerSchema\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x12 \n" +
	"\vdescription\x18\x02 \x01(\tR\vdescription\x12\x14\n" +
	"\x05owner\x18\x03 \x01(\tR\x05owner\x12\x1c\n" +
	"\tnamespace\x18\x04 \x01(\tR\tnamespace\x12\x16\n" +
	"\x06prefix\x18\x05 \x01(\tR\x06prefix\x12&\n" +
	"\x04keys\x18\x06 \x03(\v2\x12.schema.LeafSchemaR\x04keys\x12*\n" +
	"\x06fields\x18\a \x03(\v2\x12.schema.LeafSchemaR\x06fields\x124\n" +
	"\tleaflists\x18\b \x03(\v2\x16.schema.LeafListSchemaR\tleaflists\x12\x1a\n" +
	"\bchildren\x18\t \x03(\tR\bchildren\x12E\n" +
	"\x12mandatory_children\x18\n" +
	" \x03(\v2\x16.schema.MandatoryChildR\x11mandatoryChildren\x12>\n" +
	"\x0fmust_statements\x18\v \x03(\v2\x15.schema.MustStatementR\x0emustStatements\x12\x1f\n" +
	"\vmodule_name\x18\f \x01(\tR\n" +
	"moduleName\x12!\n" +
	"\fmax_elements\x18\r \x01(\x04R\vmaxElements\x12!\n" +
	"\fmin_elements\x18\x0e \x01(\x04R\vminElements\x120\n" +
	"\x14childs_with_defaults\x18\x0f \x03(\tR\x12childsWithDefaults\x12\x1f\n" +
	"\vis_presence\x18\x14 \x01(\bR\n" +
	"isPresence\x12\x19\n" +
	"\bis_state\x18\x15 \x01(\bR\aisState\x12&\n" +
	"\x0fis_user_ordered\x18\x16 \x01(\bR\risUserOrdered\x12\x1d\n" +
	"\n" +
	"if_feature\x18\x17 \x03(\tR\tifFeature\x123\n" +
	"\vchoice_info\x18\x1e \x01(\v2\x12.schema.ChoiceInfoR\n" +
	"choiceInfo\"?\n" +
	"\x0eMandatoryChild\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x12\x19\n" +
	"\bis_state\x18\x02 \x01(\bR\aisState\"\x97\x04\n" +
	"\x0eLeafListSchema\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x12 \n" +
	"\vdescription\x18\x02 \x01(\tR\vdescription\x12\x14\n" +
	"\x05owner\x18\x03 \x01(\tR\x05owner\x12\x1c\n" +
	"\tnamespace\x18\x04 \x01(\tR\tnamespace\x12\x16\n" +
	"\x06prefix\x18\x05 \x01(\tR\x06prefix\x12*\n" +
	"\x04type\x18\x06 \x01(\v2\x16.schema.SchemaLeafTypeR\x04type\x12\x1c\n" +
	"\tencrypted\x18\a \x01(\bR\tencrypted\x12\x1f\n" +
	"\vmodule_name\x18\b \x01(\tR\n" +
	"moduleName\x12\x14\n" +
	"\x05units\x18\t \x01(\tR\x05units\x12>\n" +
	"\x0fmust_statements\x18\v \x03(\v2\x15.schema.MustStatementR\x0emustStatements\x12\x1a\n" +
	"\bdefaults\x18\f \x03(\tR\bdefaults\x12!\n" +
	"\fmax_elements\x18\r \x01(\x04R\vmaxElements\x12!\n" +
	"\fmin_elements\x18\x0e \x01(\x04R\vminElements\x12\x19\n" +
	"\bis_state\x18\x15 \x01(\bR\aisState\x12&\n" +
	"\x0fis_user_ordered\x18\x16 \x01(\bR\risUserOrdered\x12\x1d\n" +
	"\n" +
	"if_feature\x18\x17 \x03(\tR\tifFeature\"\xe4\x03\n" +
	"\n" +
	"LeafSchema\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x12 \n" +
	"\vdescription\x18\x02 \x01(\tR\vdescription\x12\x14\n" +
	"\x05owner\x18\x03 \x01(\tR\x05owner\x12\x1c\n" +
	"\tnamespace\x18\x04 \x01(\tR\tnamespace\x12\x16\n" +
	"\x06prefix\x18\x05 \x01(\tR\x06prefix\x12*\n" +
	"\x04type\x18\x06 \x01(\v2\x16.schema.SchemaLeafTypeR\x04type\x12\x1c\n" +
	"\tencrypted\x18\a \x01(\bR\tencrypted\x12!\n" +
	"\fis_mandatory\x18\b \x01(\bR\visMandatory\x12\x14\n" +
	"\x05units\x18\t \x01(\tR\x05units\x12\x1f\n" +
	"\vmodule_name\x18\n" +
	" \x01(\tR\n" +
	"moduleName\x12>\n" +
	"\x0fmust_statements\x18\v \x03(\v2\x15.schema.MustStatementR\x0emustStatements\x12\x18\n" +
	"\adefault\x18\f \x01(\tR\adefault\x12\x19\n" +
	"\bis_state\x18\x15 \x01(\bR\aisState\x12\x1d\n" +
	"\n" +
	"if_feature\x18\x17 \x03(\tR\tifFeature\x12\x1c\n" +
	"\treference\x18\x19 \x03(\tR\treference\"\xbe\x06\n" +
	"\x0eSchemaLeafType\x12\x12\n" +
	"\x04type\x18\x01 \x01(\tR\x04type\x12.\n" +
	"\x05range\x18\x02 \x03(\v2\x18.schema.SchemaMinMaxTypeR\x05range\x120\n" +
	"\x06length\x18\x03 \x03(\v2\x18.schema.SchemaMinMaxTypeR\x06length\x12\x1d\n" +
	"\n" +
	"enum_names\x18\x04 \x03(\tR\tenumNames\x12\x14\n" +
	"\x05units\x18\x05 \x01(\tR\x05units\x12\x1b\n" +
	"\ttype_name\x18\x06 \x01(\tR\btypeName\x12\x18\n" +
	"\aleafref\x18\a \x01(\tR\aleafref\x12+\n" +
	"\x11optional_instance\x18\b \x01(\bR\x10optionalInstance\x121\n" +
	"\bpatterns\x18\t \x03(\v2\x15.schema.SchemaPatternR\bpatterns\x127\n" +
	"\vunion_types\x18\n" +
	" \x03(\v2\x16.schema.SchemaLeafTypeR\n" +
	"unionTypes\x12c\n" +
	"\x15identity_prefixes_map\x18\v \x03(\v2/.schema.SchemaLeafType.IdentityPrefixesMapEntryR\x13identityPrefixesMap\x12W\n" +
	"\x11module_prefix_map\x18\f \x03(\v2+.schema.SchemaLeafType.ModulePrefixMapEntryR\x0fmodulePrefixMap\x12F\n" +
	"\x13leafref_target_type\x18\r \x01(\v2\x16.schema.SchemaLeafTypeR\x11leafrefTargetType\x12\x1f\n" +
	"\x04bits\x18\x0e \x03(\v2\v.schema.BitR\x04bits\x1aF\n" +
	"\x18IdentityPrefixesMapEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\x1aB\n" +
	"\x14ModulePrefixMapEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"C\n" +
	"\rMustStatement\x12\x1c\n" +
	"\tstatement\x18\x01 \x01(\tR\tstatement\x12\x14\n" +
	"\x05error\x18\x02 \x01(\tR\x05error\"\x83\x01\n" +
	"\bPathElem\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x12+\n" +
	"\x03key\x18\x02 \x03(\v2\x19.schema.PathElem.KeyEntryR\x03key\x1a6\n" +
	"\bKeyEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01\"\\\n" +
	"\x04Path\x12\x16\n" +
	"\x06origin\x18\x02 \x01(\tR\x06origin\x12$\n" +
	"\x04elem\x18\x03 \x03(\v2\x10.schema.PathElemR\x04elem\x12\x16\n" +
	"\x06target\x18\x04 \x01(\tR\x06target\"E\n" +
	"\rSchemaPattern\x12\x18\n" +
	"\apattern\x18\x01 \x01(\tR\apattern\x12\x1a\n" +
	"\binverted\x18\x02 \x01(\bR\binverted\"V\n" +
	"\x10SchemaMinMaxType\x12 \n" +
	"\x03min\x18\x01 \x01(\v2\x0e.schema.NumberR\x03min\x12 \n" +
	"\x03max\x18\x02 \x01(\v2\x0e.schema.NumberR\x03max\":\n" +
	"\x06Number\x12\x14\n" +
	"\x05value\x18\x01 \x01(\x04R\x05value\x12\x1a\n" +
	"\bnegative\x18\x02 \x01(\bR\bnegative\"5\n" +
	"\x03Bit\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x12\x1a\n" +
	"\bposition\x18\x02 \x01(\rR\bposition\"\x99\x01\n" +
	"\n" +
	"ChoiceInfo\x126\n" +
	"\x06choice\x18\x01 \x03(\v2\x1e.schema.ChoiceInfo.ChoiceEntryR\x06choice\x1aS\n" +
	"\vChoiceEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12.\n" +
	"\x05value\x18\x02 \x01(\v2\x18.schema.ChoiceInfoChoiceR\x05value:\x028\x01\"\x97\x01\n" +
	"\x10ChoiceInfoChoice\x126\n" +
	"\x04case\x18\x01 \x03(\v2\".schema.ChoiceInfoChoice.CaseEntryR\x04case\x1aK\n" +
	"\tCaseEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12(\n" +
	"\x05value\x18\x02 \x01(\v2\x12.schema.ChoiceCaseR\x05value:\x028\x01\"(\n" +
	"\n" +
	"ChoiceCase\x12\x1a\n" +
	"\belements\x18\x01 \x03(\tR\belements*C\n" +
	"\fSchemaStatus\x12\x06\n" +
	"\x02OK\x10\x00\x12\r\n" +
	"\tRELOADING\x10\x01\x12\x10\n" +
	"\fINITIALIZING\x10\x02\x12\n" +
	"\n" +
	"\x06FAILED\x10\x03**\n" +
	"\bDataType\x12\a\n" +
	"\x03ALL\x10\x00\x12\n" +
	"\n" +
	"\x06CONFIG\x10\x01\x12\t\n" +
	"\x05STATE\x10\x022\xe4\x05\n" +
	"\fSchemaServer\x12U\n" +
	"\x10GetSchemaDetails\x12\x1f.schema.GetSchemaDetailsRequest\x1a .schema.GetSchemaDetailsResponse\x12C\n" +
	"\n" +
	"ListSchema\x12\x19.schema.ListSchemaRequest\x1a\x1a.schema.ListSchemaResponse\x12@\n" +
	"\tGetSchema\x12\x18.schema.GetSchemaRequest\x1a\x19.schema.GetSchemaResponse\x12I\n" +
	"\fCreateSchema\x12\x1b.schema.CreateSchemaRequest\x1a\x1c.schema.CreateSchemaResponse\x12I\n" +
	"\fReloadSchema\x12\x1b.schema.ReloadSchemaRequest\x1a\x1c.schema.ReloadSchemaResponse\x12I\n" +
	"\fDeleteSchema\x12\x1b.schema.DeleteSchemaRequest\x1a\x1c.schema.DeleteSchemaResponse\x12K\n" +
	"\fUploadSchema\x12\x1b.schema.UploadSchemaRequest\x1a\x1c.schema.UploadSchemaResponse(\x01\x127\n" +
	"\x06ToPath\x12\x15.schema.ToPathRequest\x1a\x16.schema.ToPathResponse\x12C\n" +
	"\n" +
	"ExpandPath\x12\x19.schema.ExpandPathRequest\x1a\x1a.schema.ExpandPathResponse\x12J\n" +
	"\x11GetSchemaElements\x12\x18.schema.GetSchemaRequest\x1a\x19.schema.GetSchemaResponse0\x01B\x11Z\x0f.;schema_serverb\x06proto3"

var (
	file_schema_proto_rawDescOnce sync.Once
	file_schema_proto_rawDescData []byte
)

func file_schema_proto_rawDescGZIP() []byte {
	file_schema_proto_rawDescOnce.Do(func() {
		file_schema_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_schema_proto_rawDesc), len(file_schema_proto_rawDesc)))
	})
	return file_schema_proto_rawDescData
}

var file_schema_proto_enumTypes = make([]protoimpl.EnumInfo, 4)
var file_schema_proto_msgTypes = make([]protoimpl.MessageInfo, 43)
var file_schema_proto_goTypes = []any{
	(SchemaStatus)(0),                // 0: schema.SchemaStatus
	(DataType)(0),                    // 1: schema.DataType
	(UploadSchemaFile_FileType)(0),   // 2: schema.UploadSchemaFile.FileType
	(Hash_HashMethod)(0),             // 3: schema.Hash.HashMethod
	(*Schema)(nil),                   // 4: schema.Schema
	(*GetSchemaDetailsRequest)(nil),  // 5: schema.GetSchemaDetailsRequest
	(*GetSchemaDetailsResponse)(nil), // 6: schema.GetSchemaDetailsResponse
	(*ListSchemaRequest)(nil),        // 7: schema.ListSchemaRequest
	(*ListSchemaResponse)(nil),       // 8: schema.ListSchemaResponse
	(*GetSchemaRequest)(nil),         // 9: schema.GetSchemaRequest
	(*GetSchemaResponse)(nil),        // 10: schema.GetSchemaResponse
	(*SchemaElem)(nil),               // 11: schema.SchemaElem
	(*CreateSchemaRequest)(nil),      // 12: schema.CreateSchemaRequest
	(*CreateSchemaResponse)(nil),     // 13: schema.CreateSchemaResponse
	(*ReloadSchemaRequest)(nil),      // 14: schema.ReloadSchemaRequest
	(*ReloadSchemaResponse)(nil),     // 15: schema.ReloadSchemaResponse
	(*DeleteSchemaRequest)(nil),      // 16: schema.DeleteSchemaRequest
	(*DeleteSchemaResponse)(nil),     // 17: schema.DeleteSchemaResponse
	(*UploadSchemaRequest)(nil),      // 18: schema.UploadSchemaRequest
	(*UploadSchemaFile)(nil),         // 19: schema.UploadSchemaFile
	(*ToPathRequest)(nil),            // 20: schema.ToPathRequest
	(*ToPathResponse)(nil),           // 21: schema.ToPathResponse
	(*ExpandPathRequest)(nil),        // 22: schema.ExpandPathRequest
	(*ExpandPathResponse)(nil),       // 23: schema.ExpandPathResponse
	(*Hash)(nil),                     // 24: schema.Hash
	(*UploadSchemaFinalize)(nil),     // 25: schema.UploadSchemaFinalize
	(*UploadSchemaResponse)(nil),     // 26: schema.UploadSchemaResponse
	(*ContainerSchema)(nil),          // 27: schema.ContainerSchema
	(*MandatoryChild)(nil),           // 28: schema.MandatoryChild
	(*LeafListSchema)(nil),           // 29: schema.LeafListSchema
	(*LeafSchema)(nil),               // 30: schema.LeafSchema
	(*SchemaLeafType)(nil),           // 31: schema.SchemaLeafType
	(*MustStatement)(nil),            // 32: schema.MustStatement
	(*PathElem)(nil),                 // 33: schema.PathElem
	(*Path)(nil),                     // 34: schema.Path
	(*SchemaPattern)(nil),            // 35: schema.SchemaPattern
	(*SchemaMinMaxType)(nil),         // 36: schema.SchemaMinMaxType
	(*Number)(nil),                   // 37: schema.Number
	(*Bit)(nil),                      // 38: schema.Bit
	(*ChoiceInfo)(nil),               // 39: schema.ChoiceInfo
	(*ChoiceInfoChoice)(nil),         // 40: schema.ChoiceInfoChoice
	(*ChoiceCase)(nil),               // 41: schema.ChoiceCase
	nil,                              // 42: schema.SchemaLeafType.IdentityPrefixesMapEntry
	nil,                              // 43: schema.SchemaLeafType.ModulePrefixMapEntry
	nil,                              // 44: schema.PathElem.KeyEntry
	nil,                              // 45: schema.ChoiceInfo.ChoiceEntry
	nil,                              // 46: schema.ChoiceInfoChoice.CaseEntry
}
var file_schema_proto_depIdxs = []int32{
	0,  // 0: schema.Schema.status:type_name -> schema.SchemaStatus
	4,  // 1: schema.GetSchemaDetailsRequest.schema:type_name -> schema.Schema
	4,  // 2: schema.GetSchemaDetailsResponse.schema:type_name -> schema.Schema
	4,  // 3: schema.ListSchemaResponse.schema:type_name -> schema.Schema
	34, // 4: schema.GetSchemaRequest.path:type_name -> schema.Path
	4,  // 5: schema.GetSchemaRequest.schema:type_name -> schema.Schema
	11, // 6: schema.GetSchemaResponse.schema:type_name -> schema.SchemaElem
	27, // 7: schema.SchemaElem.container:type_name -> schema.ContainerSchema
	30, // 8: schema.SchemaElem.field:type_name -> schema.LeafSchema
	29, // 9: schema.SchemaElem.leaflist:type_name -> schema.LeafListSchema
	4,  // 10: schema.CreateSchemaRequest.schema:type_name -> schema.Schema
	4,  // 11: schema.CreateSchemaResponse.schema:type_name -> schema.Schema
	4,  // 12: schema.ReloadSchemaRequest.schema:type_name -> schema.Schema
	4,  // 13: schema.DeleteSchemaRequest.schema:type_name -> schema.Schema
	12, // 14: schema.UploadSchemaRequest.create_schema:type_name -> schema.CreateSchemaRequest
	19, // 15: schema.UploadSchemaRequest.schema_file:type_name -> schema.UploadSchemaFile
	25, // 16: schema.UploadSchemaRequest.finalize:type_name -> schema.UploadSchemaFinalize
	2,  // 17: schema.UploadSchemaFile.file_type:type_name -> schema.UploadSchemaFile.FileType
	24, // 18: schema.UploadSchemaFile.hash:type_name -> schema.Hash
	4,  // 19: schema.ToPathRequest.schema:type_name -> schema.Schema
	34, // 20: schema.ToPathResponse.path:type_name -> schema.Path
	34, // 21: schema.ExpandPathRequest.path:type_name -> schema.Path
	4,  // 22: schema.ExpandPathRequest.schema:type_name -> schema.Schema
	1,  // 23: schema.ExpandPathRequest.data_type:type_name -> schema.DataType
	34, // 24: schema.ExpandPathResponse.path:type_name -> schema.Path
	3,  // 25: schema.Hash.method:type_name -> schema.Hash.HashMethod
	30, // 26: schema.ContainerSchema.keys:type_name -> schema.LeafSchema
	30, // 27: schema.ContainerSchema.fields:type_name -> schema.LeafSchema
	29, // 28: schema.ContainerSchema.leaflists:type_name -> schema.LeafListSchema
	28, // 29: schema.ContainerSchema.mandatory_children:type_name -> schema.MandatoryChild
	32, // 30: schema.ContainerSchema.must_statements:type_name -> schema.MustStatement
	39, // 31: schema.ContainerSchema.choice_info:type_name -> schema.ChoiceInfo
	31, // 32: schema.LeafListSchema.type:type_name -> schema.SchemaLeafType
	32, // 33: schema.LeafListSchema.must_statements:type_name -> schema.MustStatement
	31, // 34: schema.LeafSchema.type:type_name -> schema.SchemaLeafType
	32, // 35: schema.LeafSchema.must_statements:type_name -> schema.MustStatement
	36, // 36: schema.SchemaLeafType.range:type_name -> schema.SchemaMinMaxType
	36, // 37: schema.SchemaLeafType.length:type_name -> schema.SchemaMinMaxType
	35, // 38: schema.SchemaLeafType.patterns:type_name -> schema.SchemaPattern
	31, // 39: schema.SchemaLeafType.union_types:type_name -> schema.SchemaLeafType
	42, // 40: schema.SchemaLeafType.identity_prefixes_map:type_name -> schema.SchemaLeafType.IdentityPrefixesMapEntry
	43, // 41: schema.SchemaLeafType.module_prefix_map:type_name -> schema.SchemaLeafType.ModulePrefixMapEntry
	31, // 42: schema.SchemaLeafType.leafref_target_type:type_name -> schema.SchemaLeafType
	38, // 43: schema.SchemaLeafType.bits:type_name -> schema.Bit
	44, // 44: schema.PathElem.key:type_name -> schema.PathElem.KeyEntry
	33, // 45: schema.Path.elem:type_name -> schema.PathElem
	37, // 46: schema.SchemaMinMaxType.min:type_name -> schema.Number
	37, // 47: schema.SchemaMinMaxType.max:type_name -> schema.Number
	45, // 48: schema.ChoiceInfo.choice:type_name -> schema.ChoiceInfo.ChoiceEntry
	46, // 49: schema.ChoiceInfoChoice.case:type_name -> schema.ChoiceInfoChoice.CaseEntry
	40, // 50: schema.ChoiceInfo.ChoiceEntry.value:type_name -> schema.ChoiceInfoChoice
	41, // 51: schema.ChoiceInfoChoice.CaseEntry.value:type_name -> schema.ChoiceCase
	5,  // 52: schema.SchemaServer.GetSchemaDetails:input_type -> schema.GetSchemaDetailsRequest
	7,  // 53: schema.SchemaServer.ListSchema:input_type -> schema.ListSchemaRequest
	9,  // 54: schema.SchemaServer.GetSchema:input_type -> schema.GetSchemaRequest
	12, // 55: schema.SchemaServer.CreateSchema:input_type -> schema.CreateSchemaRequest
	14, // 56: schema.SchemaServer.ReloadSchema:input_type -> schema.ReloadSchemaRequest
	16, // 57: schema.SchemaServer.DeleteSchema:input_type -> schema.DeleteSchemaRequest
	18, // 58: schema.SchemaServer.UploadSchema:input_type -> schema.UploadSchemaRequest
	20, // 59: schema.SchemaServer.ToPath:input_type -> schema.ToPathRequest
	22, // 60: schema.SchemaServer.ExpandPath:input_type -> schema.ExpandPathRequest
	9,  // 61: schema.SchemaServer.GetSchemaElements:input_type -> schema.GetSchemaRequest
	6,  // 62: schema.SchemaServer.GetSchemaDetails:output_type -> schema.GetSchemaDetailsResponse
	8,  // 63: schema.SchemaServer.ListSchema:output_type -> schema.ListSchemaResponse
	10, // 64: schema.SchemaServer.GetSchema:output_type -> schema.GetSchemaResponse
	13, // 65: schema.SchemaServer.CreateSchema:output_type -> schema.CreateSchemaResponse
	15, // 66: schema.SchemaServer.ReloadSchema:output_type -> schema.ReloadSchemaResponse
	17, // 67: schema.SchemaServer.DeleteSchema:output_type -> schema.DeleteSchemaResponse
	26, // 68: schema.SchemaServer.UploadSchema:output_type -> schema.UploadSchemaResponse
	21, // 69: schema.SchemaServer.ToPath:output_type -> schema.ToPathResponse
	23, // 70: schema.SchemaServer.ExpandPath:output_type -> schema.ExpandPathResponse
	10, // 71: schema.SchemaServer.GetSchemaElements:output_type -> schema.GetSchemaResponse
	62, // [62:72] is the sub-list for method output_type
	52, // [52:62] is the sub-list for method input_type
	52, // [52:52] is the sub-list for extension type_name
	52, // [52:52] is the sub-list for extension extendee
	0,  // [0:52] is the sub-list for field type_name
}

func init() { file_schema_proto_init() }
func file_schema_proto_init() {
	if File_schema_proto != nil {
		return
	}
	file_schema_proto_msgTypes[7].OneofWrappers = []any{
		(*SchemaElem_Container)(nil),
		(*SchemaElem_Field)(nil),
		(*SchemaElem_Leaflist)(nil),
	}
	file_schema_proto_msgTypes[14].OneofWrappers = []any{
		(*UploadSchemaRequest_CreateSchema)(nil),
		(*UploadSchemaRequest_SchemaFile)(nil),
		(*UploadSchemaRequest_Finalize)(nil),
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_schema_proto_rawDesc), len(file_schema_proto_rawDesc)),
			NumEnums:      4,
			NumMessages:   43,
			NumExtensions: 0,
			NumServices:   1,
		},
		GoTypes:           file_schema_proto_goTypes,
		DependencyIndexes: file_schema_proto_depIdxs,
		EnumInfos:         file_schema_proto_enumTypes,
		MessageInfos:      file_schema_proto_msgTypes,
	}.Build()
	File_schema_proto = out.File
	file_schema_proto_goTypes = nil
	file_schema_proto_depIdxs = nil
}
